import path from "path";
import fs from "fs";
import util from "util";
import { DataTypes, Sequelize } from "sequelize";
import downloadModels from "./download-models.ts";

const readFileAsync = util.promisify(fs.readFile);

/**
 * Convert type string to generic type
 * @param  {string} type Type string
 * @return {string} Generic type string
 */
function convertToGenericType(type: string): string {
	const genericType = type.replace(/\(\d+\)$/, "");
	switch (genericType) {
		case "DATETIME2":
		case "TIMESTAMP":
		case "DATETIMEOFFSET":
			return "DATETIME";
		case "DOUBLE PRECISION":
			return "NUMERIC";
		case "INTEGER":
		case "TINYINT":
		case "SMALLINT":
			return "INT";
		case "NVARCHAR(MAX)":
			return "TEXT";
		case "NVARCHAR":
			return "VARCHAR";
		case "UUIDV4":
			return "UNIQUEIDENTIFIER";
		default:
			return genericType;
	}
}

/**
 * Check if models match database tables
 * @param  {Object} [options={}] Options
 * @param  {string} [options.database] Database name
 * @param  {string} [options.username] Datbase username
 * @param  {string} [options.password] Database password
 * @param  {string} [options.host] Database host
 * @param  {int} [options.port] Database port
 * @param  {string} [options.dialect] Database dialect ("mysql"|"mssql")
 * @param  {string} [options.directory] Model directory
 * @param  {Array<string>} [options.tables] Database tables
 * @param  {Object} [options.dialectOptions] Database options
 * @param  {bool} [options.includeViews] Include views along with tables
 * @param  {bool} [options.quiet] Don't output to stdout
 * @param  {bool} [options.sort] Sort fields and attributes
 * @param  {bool|EventEmitter} [options.output] FALSE = Reject error string, TRUE(default) = Output errors to console, EventEmitter = emit "error" for each error
 * @return {Promise<void>} Resolves on success
 */

interface CheckModelsOptions {
	database?: string;
	username?: string;
	password?: string;
	host?: string;
	port?: number;
	dialect?: "mysql" | "mssql" | "postgres" | "sqlite"; // Assuming these are the supported dialects
	directory: string; // Made directory mandatory as it's used directly
	tables?: string[];
	dialectOptions?: any; // Consider defining a more specific type
	includeViews?: boolean;
	quiet?: boolean;
	sort?: boolean;
	output?: boolean | import("events").EventEmitter; // For EventEmitter
}

interface AutoGeneratedAttributes {
	[columnName: string]: {
		type: string;
		// Add other properties if available from downloadModels
	};
}

interface AutoGeneratedData {
	tables: {
		[tableName: string]: AutoGeneratedAttributes;
	};
	text: {
		[tableName: string]: string;
	};
	sequelize: Sequelize; // Assuming downloadModels returns a Sequelize instance
	// Add other properties if returned by downloadModels
}


async function checkModels(options: CheckModelsOptions): Promise<void> {
	const { directory, ...opts } = options;
	const output = options.output === undefined ? true : options.output; // Default to true if undefined
	// opts still contains properties of CheckModelsOptions excluding directory and potentially output
	// We need to ensure that the properties passed to downloadModels are correct.
	// For now, we cast to `any` but this should be refined based on downloadModels' actual signature.
	const autoOpts: any = { ...opts };
	if (options.output === undefined || typeof options.output === 'boolean') {
		delete autoOpts.output; // downloadModels might not expect 'output' if it's a boolean
	}


	const auto: AutoGeneratedData = await downloadModels({
		...autoOpts,
		directory: false, // downloadModels specific option
	});

	let log = "";

	function logError(msg: string) {
		if (typeof output === "object" && "emit" in output && typeof output.emit === 'function') {
			if (msg.trim()) {
				output.emit("error", msg);
			}
		} else if (output) {
			// eslint-disable-next-line no-console
			console.error(msg);
		} else {
			log += msg;
		}
	}

	logError("\n");
	let isError = false;

	for (const table in auto.tables) {
		const file = path.resolve(directory, `${table}.ts`); // Changed to .ts

		try {
			const text = auto.text[table];
			// TODO: The model file is now .ts, so require(file) will not work directly.
			// This needs to be handled, possibly by compiling .ts to .js first or using a .ts runtime.
			// For now, we'll assume it can be required, but this is a placeholder.
			let model;
			let data = "";
			try {
				data = await readFileAsync(file, { encoding: "utf8" });
			} catch (readEx: any) {
				isError = true;
				if (readEx.code === "ENOENT") {
					logError(`No model file for '${table}' at ${file}`);
				} else {
					logError(`Error reading model file '${file}': ${readEx.message}`);
				}
				continue; // Skip to next table if model file can't be read
			}


			if (text !== data) {
				try {
					// This part is problematic as require() won't work with TS files directly
					// Needs a build step or ts-node. For now, this logic will likely fail.
					const modelModule = require(file); // This will fail for .ts files in a standard Node runtime
					model = modelModule.default || modelModule; // Handle ES6 default export or CJS
					if (typeof model !== 'function') {
						// If it's an object (like the result of `sequelize.define`), try to find the init function or use it directly
						// This is a heuristic and might need adjustment based on actual model structure
						if (model.init && typeof model.init === 'function') {
							// This case is unlikely if the file exports a function like in the original JS
						} else if (typeof model === 'object' && model.rawAttributes) {
							// Assume 'model' is already the defined Sequelize model
						} else {
							throw new Error("Model definition not found or not a function/Sequelize model object.");
						}
					} else {
                        // If it's a function, it needs to be called with sequelize and DataTypes
                        // However, the `auto.sequelize` might be different from the one used to define the model
                        // This logic might need to be re-evaluated.
                        model = model(auto.sequelize, DataTypes);
                    }


					const dbModelDefinition = auto.tables[table];
					const dbColumns = Object.keys(dbModelDefinition);
					// Add default Sequelize columns if not already present in dbModelDefinition
					if (!dbColumns.includes("id")) dbColumns.push("id");
					if (!dbColumns.includes("createdAt")) dbColumns.push("createdAt");
					if (!dbColumns.includes("updatedAt")) dbColumns.push("updatedAt");

					const modelAttributes = model.rawAttributes;
					const columns = Object.keys(modelAttributes);
					const realNameColumns = columns.map(col => {
						return "field" in modelAttributes[col] ? (modelAttributes[col] as any).field : col;
					});

					realNameColumns.forEach(col => {
						const originalColumnName = columns[realNameColumns.indexOf(col)];
						const type = convertToGenericType((modelAttributes[originalColumnName] as any).type.toString());
						if (type !== "VIRTUAL") {
							if (!dbColumns.includes(col)) {
								logError(`'${table}.${col}' not in db`);
								isError = true;
							}
						}
					});

					for (const col in dbModelDefinition) {
						if (!realNameColumns.includes(col)) {
							logError(`'${table}.${col}' not in model`);
							isError = true;
						} else {
							const originalColumnName = columns[realNameColumns.indexOf(col)];
							const type = convertToGenericType((modelAttributes[originalColumnName] as any).type.toString());
							const dbType = convertToGenericType(dbModelDefinition[col].type);
							if (type !== dbType) {
								logError(`'${table}.${col}' types not equal '${type}' !== '${dbType}'`);
								isError = true;
							}
						}
					}

				} catch (ex: any) {
					isError = true;
					if (ex.message.match(/^Cannot find module/) || ex.code === 'MODULE_NOT_FOUND') {
						logError(`No model definition found for '${table}' or error loading it. Model file: ${file}`);
					} else {
						logError(`'${table}' Error processing model: ${ex.message}`);
					}
				}
				if (!isError && text !==data) { // check isError again because it might have been set in the inner try-catch
					isError = true;
					logError(`'${table}' text has changed (but model structure might be compatible or failed to load)`);
				}
			}
		} catch (ex: any) {
			isError = true;
			if (ex.code === "ENOENT") {
				logError(`No model file for '${table}' at ${path.resolve(directory, `${table}.ts`)}`);
			} else {
				logError(`'${table}' Error: ${ex.message}`);
			}
		}
	}

	if (isError) {
		logError("\n");
		if (log && !output) { // Only throw if not outputting to console/EventEmitter
			throw new Error(log);
		} else if (log && typeof output === "object" && "emit" in output) {
            // If using EventEmitter, we've already emitted errors.
            // Decide if an additional summary error is needed or if it's implied by previous emissions.
            // For now, let's assume individual errors are sufficient.
        } else if (log && output === true) {
             // Errors already printed to console.
        }
	}
}

export default checkModels;
